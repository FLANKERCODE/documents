1.快速排序
思路：挖坑填数+分治法
static void quickSort(int[] s,int start,int end){    //end为排序范围的最后一个，包含end，从小到大排序
	if(start<end){
		int base=s[start];
		int i=start,j=end;
		while(i<j){
			while(s[j]>=base && i<j){j--;}
			if(i<j) s[i++]=s[j];
			while(s[i]<=base&&i<j){i++;}
			if(i<j) s[j--]=s[i];
		}
		s[i]=base;
		quickSort(s,start,i-1);
		quickSort(s,i+1,end);
	}
}


2.贪心算法（Greedy Algorithm）
基本归纳法：对A(i+1)，只需考察前一个状态A(i)即可完成整个推理过程，特点是，只要状态A(i)确定，则计算A(i+1)不需要考虑更前序的状态A1，A2，...,A(i-1),在图论中，常常称为马尔科夫模型。
a.建立数学模型来描述问题
b.把求解的问题分成若干个子问题
c.对每一子问题求解，得到子问题的局部最优解
d.把子问题的解局部最优解合成原来解问题的一个解

求最小生成树(MST):
要求从一个带权无向连通图中选择n-1条边，并使这个图仍然连通（也即得到了一棵生成树），同时还要考虑使树的权最小。
a.Prim算法：从某个（任意一个）结点出发，选择与该结点邻接的权值最小的边；随着结点的不断加入，每次都选择这些结点发出的边中权值最小的，重复n-1次
b.Kruskal算法：将边按照权值递增排序，每次选择权值最小并且不构成环的边，重复n-1次
c.Dijkstra最短路径算法：
-------经典场景-------





3.动态规划
高阶归纳法：相应的，对于A(i+1)，需考虑前i个状态集{A1，A2，...,A(i)}才可完成整个推理过程，往往称为高阶马尔科夫模型。
无后效性：A(i+1)的值只和前序状态有关，和后续状态无关;！重点需要得到递推关系！！

最长递增子序列(LIS):
给定一个长度为N的数组，找出一个最长的单调递增子序列（不一定连续，但是顺序不能乱）。如：给定长度为6的数组A{5,6,7,1,2,8}的最长递增子序列为{5,6,7,8}，长度为4.
思路：
法一、LIS问题可以转换成最长公子序列（LCS）。原数组A排序后得到A1{1，2，5，6，7，8},两序列的最长公共子序列的问题的解。
法二、动态规划思路
		长度为N的数组记为A={a0,a1,...,a(n-1)}
		记A的前i个字符构成的前缀串为Ai=a0a1...a(i-1),以ai结尾的最长递增子序列记做Li,其长度记为a[i]
		假定已经计算得到了a[0,1,..,i-1],如何计算a[i]
		根据定义，Li必须已ai结尾，如果a(j)<=a(i),则可以将a(i)缀到Lj后面，并且使得Lj长度变长，从而a[i]={max(a[j])+1，0<=j<=i&&a[j]<=a[i]}
			需要遍历在i之前的所有位置j，找出满足条件的a(j)<=a(i)
			计算得到a[0...n-1]后，遍历所有的a[i],找出最大值即为最大递增子序列（时间复杂度度（N^2））

		如何输出最大递增子序列的元素？
			记录前驱，也就是建立一个相同大小的数组，b(i)里面存放在以a(i)结尾的最大递增子序列的前一个元素下标。那么只需知道最大子序列的最后一个元素就可以根据反向查找确定其前面的所有元素。

矩阵乘积()
根据矩阵乘积的定义来计算C=A*B,需要m*n*s次乘法。问：给定n个矩阵的连乘积，A1*A2*...An，如何添加括号（利用结合律）来改变计算次序，使得乘法的计算量最小？
（若A,B都是方阵，C的计算时间复杂度为O（n*3））
思路：
法一、分治法：Strassen分块
法二、动态规划思路
		将矩阵乘积AiAi+1...Aj记为A[i:j],这里i<=j,若取等号，A[i:j]即A[i]本身
		考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开是最优解，i<=k<=j,则其相应的完全加括号方式为(AiAi+1...Ak)(Ak+1Ak+2...Aj)
		计算量：A[i:K]的计算量，A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量
		记计算A[i:j]所需的最少数乘次数为m[i:j],则原问题可以表示为m[1:n]
		记Ai的维度为pi-1*Pi,那么m[i:j]=m[i:k]+m[k+1:j]+pi-1*pk*pj,从而m[i:j]=min{m[i:k]+m[k+1:j]+pi-1*pk*pj},i<=k<j;m[i:j]=0,i=j.（那么，要计算m[i;j],需要知道m[i+1:j],m[i+2:j],...,m[j-1:j]）
